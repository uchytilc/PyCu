

			# builder.store(val, vec._get_ptr_by_index(0))
			# return builder.store(val, vec._get_ptr_by_index(0))

			# print(dir(builder))
			# print(dir(context))

			# print(valty, val)
			# print(dir(val))

			# print(dir(target))
			# print(target._get_reference(), type(target._get_reference()))
			# cgutils.create_struct_proxy(typ)(context, builder, ref=target)

			# ################
			# vec = cgutils.create_struct_proxy(typ)(context, builder, value=target)
			# val = context.cast(builder, val, valty, typ.member_type)

			# # print(target)
			# # print(vec._value)
			# # print(vec._outer_ref)
			# # vec.x = val

			# # a = builder.store(val, vec._get_ptr_by_index(0))
			# a = builder.store(val, vec._get_ptr_by_index(0))

			# ################



			# print(dir(target))
			# print(target.)

			# structval = cgutils.create_struct_proxy(typ)(context, builder, value=target)

			# print(dir(structval))
			# print(structval._context, type(structval._context))
			# print(structval._datamodel, type(structval._datamodel))
			# print(structval._getpointer(), type(structval._getpointer()))
			# print(structval._getvalue, type(structval._getvalue))
			# print(structval._setvalue, type(structval._setvalue))
			# print(structval, type(structval))
			# print(structval, type(structval))

				# structval._meminfo
				# meminfo = structval.meminfo
				# data_ptr = context.nrt.meminfo_data(builder, meminfo)
			# context.nrt.meminfo_data

			# data_ptr = self.get_data_pointer(target)


			# valtype = struct_type.get_data_type()
			# dataval = cgutils.create_struct_proxy(valtype)(
			#	 context, builder, ref=data_ptr
			# )
			# return dataval


			#target.align #(None)

			# print(dir(target))
			# print(target.get_reference())

			# vec = cgutils.create_struct_proxy(typ)(context, builder, value=target)


			# cgutils.gep(builder, target, 0 , 0)

			# dptr = cgutils.get_record_member(builder, target, 0, typ.member_type)
									# def get_record_member(builder, record, offset, typ):
									#	 pval = gep_inbounds(builder, record, 0, offset)
									#	 assert not is_pointer(pval.type.pointee)
									#	 return builder.bitcast(pval, typ.as_pointer())

			# print(dir(target))
			# val.get_reference()

			# context.pack_value(builder, typ.member_type, val, vec._get_ptr_by_index(0))


			# out_ptr = builder.gep(target, 0, name='', inbounds=True) #?
			# builder.store(val, out_ptr)

			# print(structval._get_ptr_by_index(0))
			# print(structval._get_ptr_by_index(1))
			# print(structval._get_ptr_by_index(2))

			# ################
			# val = context.cast(builder, val, valty, typ.member_type)
			# structval.x = val
			# builder.store(val, structval._get_ptr_by_index(0))
			# ################

















#const = context.get_constant(dtype, 0) #np.inf, np.nan





# numba/numba/cpython/numbers.py
# # with builder.if_then(builder.not_(is_overflow), likely=True):
# #		 # Note LLVM will optimize this to a single divmod instruction,
# #		 # if available on the target CPU (e.g. x86).
# #		 xdivy = builder.sdiv(x, y)
# #		 xmody = builder.srem(x, y)

# #		 y_xor_xmody_ltz = builder.icmp_signed('<', builder.xor(y, xmody), ZERO)
# #		 xmody_istrue = builder.icmp_signed('!=', xmody, ZERO)
# #		 cond = builder.and_(xmody_istrue, y_xor_xmody_ltz)

# #	 with builder.if_then(builder.not_(is_overflow), likely=True):
# #		 # Note LLVM will optimize this to a single divmod instruction,
# #		 # if available on the target CPU (e.g. x86).
# #		 xdivy = builder.sdiv(x, y)
# #		 xmody = builder.srem(x, y)

# #		 y_xor_xmody_ltz = builder.icmp_signed('<', builder.xor(y, xmody), ZERO)
# #		 xmody_istrue = builder.icmp_signed('!=', xmody, ZERO)
# #		 cond = builder.and_(xmody_istrue, y_xor_xmody_ltz)

# #		 with builder.if_else(cond) as (if_different_signs, if_same_signs):
# #			 with if_same_signs:
# #				 builder.store(xdivy, resdiv)
# #				 builder.store(xmody, resmod)

# #			 with if_different_signs:
# #				 builder.store(builder.sub(xdivy, ONE), resdiv)
# #				 builder.store(builder.add(xmody, y), resmod)

# #EXAMPLE
# def builder_op_caller(op,builder,rtrn,*args):
# 	for n, attr in enumerate(rtrn._fe_type.member_names):
# 		setattr(rtrn, attr, op(*[arg[n] for arg in args]))
# 	return rtrn._getvalue()

# 	# cond = builder.fcmp_unordered('<=', args[0][0], args[0][1])
# 	# with builder.if_else(cond) as (opt_a, opt_b):
# 	# 	with opt_a:
# 	# 		val = op(args[0][0], args[1][0])
# 	# 		builder.store(val, rtrn._get_ptr_by_index(0))

# 	# 	with opt_b:
# 	# 		val = op(args[0][0], args[0][1])
# 	# 		builder.store(val, rtrn._get_ptr_by_index(0))

# 	# return rtrn._getvalue()













	# @cuda_lower(abs, vectype)
	# @cuda_lower(core.abs, vectype)
	# def cuda_abs_vec(context, builder, sig, args):
	# 	a = cgutils.create_struct_proxy(sig.return_type)(context, builder, value = args[0])
	# 	out = cgutils.create_struct_proxy(sig.return_type)(context, builder)

	# 	dtype = sig.return_type.member_type
	# 	libfunc_impl = context.get_function(core.abs, signature(dtype, dtype))
	# 	out.x = libfunc_impl(builder, [a.x]) 
	# 	out.y = libfunc_impl(builder, [a.y]) 

	# 	return out._getvalue()



















# # def unary_builder_op_factory(op, vectype, helper):
# # 	#for unary functions that do not have a core equivalent function to call
# # 	@cuda_lower(op, vectype)
# # 	def cuda_op_vec(context, builder, sig, args):
# # 		a = cgutils.create_struct_proxy(sig.return_type)(context, builder, value = args[0])
# # 		a_members = [getattr(a, attr) for attr in sig.return_type.member_names]
# # 		return helper(context,builder,vectype,a_members)

# # def builder_unary_op_helper(out,a,vectype,op):
# # 	for n, attr in enumerate(vectype.member_names):
# # 		setattr(out, attr, op(a[n]))

# # def neg_helper(context, builder,vectype,a):
# # 	out = cgutils.create_struct_proxy(vectype)(context, builder)
# # 	neg = builder.neg
# # 	if isinstance(dtype, types.Float):
# # 		neg = builder.fneg
# # 	builder_unary_op_helper(out,a,vectype,neg)
# # 	# out.x = neg(a.x)
# # 	# out.y = neg(a.y)
# # 	return out._getvalue()




# def unary_libfunc_op_factory(op, vectype, cuda_op = None):
# 	if cuda_op is None:
# 		cuda_op = op
# 	@cuda_lower(op, vectype)
# 	def cuda_unary_vec(context, builder, sig, args):
# 		a = cgutils.create_struct_proxy(sig.return_type)(context, builder, value = args[0])
# 		out = cgutils.create_struct_proxy(sig.return_type)(context, builder)

# 		sig = signature(sig.return_type.member_type,
# 						sig.return_type.member_type)
# 		libfunc_impl = context.get_function(cuda_op, sig)

# 		for n, attr in enumerate(vectype.member_names):
# 			setattr(out, attr, libfunc_impl(builder, [getattr(a, attr)]))
# 		return out._getvalue()












# #########################
# #unary callers functions#
# #########################

# #these are returned from a helper function along with the op that the caller will call

# def unary_builder_op_caller(op,builder,rtrn,a):
# 	for n, attr in enumerate(rtrn._fe_type.member_names):
# 		setattr(rtrn, attr, op(a[n]))
# 	return rtrn._getvalue()

# def unary_mathimpl_op_caller(op,builder,rtrn,a):
# 	for n, attr in enumerate(rtrn._fe_type.member_names):
# 		setattr(rtrn, attr, op(builder, a[n]))
# 	return rtrn._getvalue()

# def unary_libfunc_op_caller(op,builder,rtrn,a):
# 	for n, attr in enumerate(rtrn._fe_type.member_names):
# 		setattr(rtrn, attr, op(builder, [a[n]]))
# 	return rtrn._getvalue()


# ##########################
# #binary callers functions#
# ##########################

# def binary_builder_op_caller(op,builder,rtrn,a,b):
# 	for n, attr in enumerate(rtrn._fe_type.member_names):
# 		setattr(rtrn, attr, op(a[n], b[n]))
# 	return rtrn._getvalue()

# def binary_libfunc_op_caller(op,builder,rtrn,a,b):
# 	for n, attr in enumerate(rtrn._fe_type.member_names):
# 		setattr(rtrn, attr, op(builder, [a[n], b[n]]))
# 	return rtrn._getvalue()



# #generic libfunc helper function for binary libfuncs
# def binary_libfunc_helper_wrapper(cuda_op):
# 	def libfunc_helper(context, builder, sig, args):
# 		sig = signature(sig.return_type.member_type,
# 						sig.return_type.member_type,
# 						sig.return_type.member_type)
# 		return context.get_function(cuda_op, sig), libfunc_op_caller
# 	return binary_libfunc_helper_wrapper

# #generic libfunc helper function for unary libfuncs
# def unary_libfunc_helper_wrapper(cuda_op):
# 	def libfunc_unary_helper(context, builder, sig, args):
# 		sig = signature(sig.return_type.member_type,
# 						sig.return_type.member_type)
# 		return context.get_function(cuda_op, sig), libfunc_op_caller
# 	return unary_libfunc_helper_wrapper
